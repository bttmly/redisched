// NOTE -- THIS FILE IS AUTOGENERATED! DO NOT EDIT DIRECTLY

package redisched

// RedisDeleteScript script
const RedisDeleteScript = `-- returns 1 if a job was found and removed, 0 if not found
local topic, id = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic
local reserved_key = "__REDIS_SCHED_RESERVED__" .. topic

local jobs_del = redis.call("HDEL", jobs_key, id)
local queued_del = redis.call("ZREM", queued_key, id)
local reserved_del = redis.call("ZREM", reserved_key, id)

-- job was not present at all
if (jobs_del == 0 and queued_del == 0 and reserved_del == 0) then
  return 0
-- job was queued
elseif (jobs_del == 1 and queued_del == 1 and reserved_del == 0) then
  return 1
-- job was reserved
elseif (jobs_del == 1 and queued_del == 0 and reserved_del == 1) then
  return 1
-- we somehow got into an inconsistent state:
-- either job was BOTH queued AND reserved OR
-- job was in NEITHER queued NOR reserved
else
  return redis.error_reply("inconsistent job state -- ", jobs_del, queued_del, reserved_del)
end
`

// RedisPullScript script
const RedisPullScript = `-- returns an {id, contents} tuple if a job is ready otherwise nil
-- DELETES the job; cannot be requeud automatically later
local topic, max_score = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic
local reserved_key = "__REDIS_SCHED_RESERVED__" .. topic

local found_job = redis.call(
  "ZRANGEBYSCORE", -- operation
  queued_key, -- zset key
  0, -- min
  max_score, -- max
  "LIMIT", -- limit
  0, -- offset
  1 -- count
)

-- no job is ready
if table.getn(found_job) == 0 then
  return nil
end

local id = found_job[1]
local job = redis.call("HGET", jobs_key, id)

-- sanity check
if job == nil then
  return redis.error_response(string.format("found queued id %s but no job", id))
end

redis.call("ZREM", queued_key, id)
redis.call("HDEL", jobs_key, id)

return {id, job}
`

// RedisPutScript script
const RedisPutScript = `-- returns 1 if job put successfully, 0 otherwise (i.e. duplicate id)
local topic, id, body, score = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic

local did_add = redis.call("ZADD", queued_key, "NX", score, id)
if did_add == 0 then return 0 end

redis.call("HSET", jobs_key, id, body)

return 1
`

// RedisReleaseScript script
const RedisReleaseScript = `-- returns 1 if a job was found and removed, 0 if not found
local topic, id, score = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic
local reserved_key = "__REDIS_SCHED_RESERVED__" .. topic

-- check if job was reserved; if not, don't need to continue
-- this would happen if
-- a.) the job never existed
-- b.) the job was previously deleted
-- c.) the job was reserved but had timed out and been requeued
local result = redis.call("ZREM", reserved_key, id)
if result == 0 then
  return 0
end

-- sanity check; if id was in the reserved set, the job should exist
result = redis.call("HEXISTS", jobs_key, id)
if result == 0 then
  return redis.error_response(string.format("id %s in reserved set but job not found", id))
end

-- sanity check; if ZADD NX returns 0 here then we are in an inconsistent state
-- since ZADD NX == 0 means the id was already in the queued set and we already
-- are sure from the ZREM above that the id was in the reserved set
result = redis.call("ZADD", queued_key, "NX", score, id)
if result == 0 then
  return redis.error_response(string.format("id %s both reserved and queued", id))
end

return 1
`

// RedisRequeueScript script
const RedisRequeueScript = `-- returns a number representing number of jobs requeued
local topic, max_score, limit = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic
local reserved_key = "__REDIS_SCHED_RESERVED__" .. topic

limit = tonumber(limit)
if limit == nil then limit = 1000 end

-- get the ids of up to 'limit' jobs from the reserved set that have timed out
local ids_to_requeue = redis.call(
  "ZRANGEBYSCORE", -- operation
  reserved_key, -- zset key
  0, -- min
  max_score, -- max
  "LIMIT", -- limit
  0, -- offset
  limit -- count
)

-- shift all the ids we found from the reserved set into the queue
for _, id in ipairs(ids_to_requeue) do
  -- remove a job from reserved and put it into the queue. ZADD NX should never
  -- return 0, which would indicate the job was already in the queue
  redis.call("ZREM", reserved_key, id)
  redis.call("ZADD", queued_key, "NX", max_score, id)
end

-- return an integer representing number of jobs requeued
return table.getn(ids_to_requeue)
`

// RedisReserveScript script
const RedisReserveScript = `-- returns an {id, contents} tuple if a job is ready otherwise nil
-- puts the job in the reserved queue for later
local topic, max_score, ttr = unpack(ARGV)

local jobs_key = "__REDIS_SCHED_JOBS__" .. topic
local queued_key = "__REDIS_SCHED_QUEUED__" .. topic
local reserved_key = "__REDIS_SCHED_RESERVED__" .. topic

redis.debug("max_score", max_score);

local found_job = redis.call(
  "ZRANGEBYSCORE", -- operation
  queued_key, -- zset key
  0, -- min
  max_score, -- max
  "LIMIT", -- limit
  0, -- offset
  1 -- count
)

-- no job is ready
if table.getn(found_job) == 0 then
  return nil
end

local id = found_job[1]
local job = redis.call("HGET", jobs_key, id)

-- sanity check
if job == nil then
  return redis.error_response(string.format("found queued id %s but no job", id))
end

redis.call("ZREM", queued_key, id)
redis.call("ZADD", reserved_key, max_score + ttr, id)

return {id, job}
`